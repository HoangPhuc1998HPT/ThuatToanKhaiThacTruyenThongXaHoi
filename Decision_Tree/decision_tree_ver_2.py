import sys
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier, plot_tree
from sklearn import metrics
from PyQt5 import QtWidgets, QtCore
from PyQt5.QtWidgets import QSplitter
import warnings
import math

warnings.filterwarnings('ignore')


class ID3AnalyzerGUI(QtWidgets.QMainWindow):
    """·ª®ng d·ª•ng PyQt5 cho Decision Tree Classification v·ªõi hi·ªÉn th·ªã qu√° tr√¨nh ID3"""

    def __init__(self):
        super().__init__()
        self.setWindowTitle("ID3 Decision Tree Explorer")
        self.resize(1600, 1000)

        # Data holders
        self._df_raw = None
        self._model = None
        self._label_encoders = {}
        self._feature_names = None
        self._target_name = None
        self._X_train = None
        self._X_test = None
        self._y_train = None
        self._y_test = None

        # ID3 analysis data
        self._id3_analysis = []
        self._entropy_analysis = []

        self.setup_ui()

    def setup_ui(self):
        """Thi·∫øt l·∫≠p giao di·ªán ng∆∞·ªùi d√πng"""
        central = QtWidgets.QWidget(self)
        self.setCentralWidget(central)
        main_layout = QtWidgets.QVBoxLayout(central)

        # === FILE SELECTION ===
        file_group = QtWidgets.QGroupBox("1. Ch·ªçn d·ªØ li·ªáu")
        file_layout = QtWidgets.QHBoxLayout(file_group)

        self.file_line = QtWidgets.QLineEdit()
        self.file_line.setReadOnly(True)
        browse_btn = QtWidgets.QPushButton("Ch·ªçn file CSV...")
        browse_btn.clicked.connect(self.browse_file)

        file_layout.addWidget(QtWidgets.QLabel("File:"))
        file_layout.addWidget(self.file_line)
        file_layout.addWidget(browse_btn)

        main_layout.addWidget(file_group)

        # === DATA PREPROCESSING ===
        preprocess_group = QtWidgets.QGroupBox("2. Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu")
        preprocess_layout = QtWidgets.QVBoxLayout(preprocess_group)

        # Target selection
        target_layout = QtWidgets.QHBoxLayout()
        self.target_combo = QtWidgets.QComboBox()
        analyze_btn = QtWidgets.QPushButton("Ph√¢n t√≠ch d·ªØ li·ªáu")
        analyze_btn.clicked.connect(self.analyze_data)

        target_layout.addWidget(QtWidgets.QLabel("C·ªôt target:"))
        target_layout.addWidget(self.target_combo)
        target_layout.addWidget(analyze_btn)
        target_layout.addStretch()

        preprocess_layout.addLayout(target_layout)

        # Categorical columns selection
        cat_layout = QtWidgets.QHBoxLayout()
        self.cat_list = QtWidgets.QListWidget()
        self.cat_list.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        self.cat_list.setMaximumHeight(100)

        cat_layout.addWidget(QtWidgets.QLabel("C·ªôt categorical:"))
        cat_layout.addWidget(self.cat_list)

        preprocess_layout.addLayout(cat_layout)

        main_layout.addWidget(preprocess_group)

        # === MODEL PARAMETERS ===
        param_group = QtWidgets.QGroupBox("3. Tham s·ªë m√¥ h√¨nh")
        param_layout = QtWidgets.QVBoxLayout(param_group)  # ƒê·ªïi th√†nh VBoxLayout

        # D√≤ng ƒë·∫ßu ti√™n - c√°c tham s·ªë
        param_row1 = QtWidgets.QHBoxLayout()

        # Criterion - FIXED to entropy for ID3
        self.criterion_combo = QtWidgets.QComboBox()
        self.criterion_combo.addItems(["entropy", "gini"])
        self.criterion_combo.setCurrentText("entropy")

        # Max depth
        self.depth_spin = QtWidgets.QSpinBox()
        self.depth_spin.setRange(1, 20)
        self.depth_spin.setValue(4)

        # Test size
        self.test_size_spin = QtWidgets.QDoubleSpinBox()
        self.test_size_spin.setDecimals(2)
        self.test_size_spin.setRange(0.1, 0.5)
        self.test_size_spin.setSingleStep(0.05)
        self.test_size_spin.setValue(0.3)

        # Random state
        self.random_state_spin = QtWidgets.QSpinBox()
        self.random_state_spin.setRange(1, 1000)
        self.random_state_spin.setValue(42)

        param_row1.addWidget(QtWidgets.QLabel("Criterion:"))
        param_row1.addWidget(self.criterion_combo)
        param_row1.addWidget(QtWidgets.QLabel("Max Depth:"))
        param_row1.addWidget(self.depth_spin)
        param_row1.addWidget(QtWidgets.QLabel("Test Size:"))
        param_row1.addWidget(self.test_size_spin)
        param_row1.addWidget(QtWidgets.QLabel("Random State:"))
        param_row1.addWidget(self.random_state_spin)

        # D√≤ng th·ª© hai - c√°c n√∫t ƒëi·ªÅu khi·ªÉn
        param_row2 = QtWidgets.QHBoxLayout()

        # Train button
        train_btn = QtWidgets.QPushButton("üöÄ Hu·∫•n luy·ªán m√¥ h√¨nh & Ph√¢n t√≠ch ID3")
        train_btn.clicked.connect(self.train_model)
        param_row2.addWidget(train_btn)

        # TH√äM CHECKBOX CHO CH·∫æ ƒê·ªò HI·ªÇN TH·ªä C√ÇY
        self.detailed_tree_check = QtWidgets.QCheckBox("üìã Hi·ªÉn th·ªã c√¢y v·ªõi ch√∫ th√≠ch chi ti·∫øt")
        self.detailed_tree_check.setChecked(True)
        self.detailed_tree_check.stateChanged.connect(self.update_tree_display)
        param_row2.addWidget(self.detailed_tree_check)

        param_layout.addLayout(param_row1)
        param_layout.addLayout(param_row2)

        main_layout.addWidget(param_group)

        # === RESULTS SECTION ===
        results_splitter = QSplitter(QtCore.Qt.Horizontal)

        # Left panel - Text results v·ªõi tabs
        left_widget = QtWidgets.QWidget()
        left_layout = QtWidgets.QVBoxLayout(left_widget)

        # T·∫°o tab widget cho k·∫øt qu·∫£ text
        self.text_tabs = QtWidgets.QTabWidget()

        # Tab 1: Data info
        self.data_info_text = QtWidgets.QTextEdit()
        self.data_info_text.setReadOnly(True)
        self.text_tabs.addTab(self.data_info_text, "Th√¥ng tin d·ªØ li·ªáu")

        # Tab 2: ID3 Analysis - TH√äM M·ªöI
        self.id3_analysis_text = QtWidgets.QTextEdit()
        self.id3_analysis_text.setReadOnly(True)
        self.text_tabs.addTab(self.id3_analysis_text, "Ph√¢n t√≠ch ID3")

        # Tab 3: Model results
        self.results_text = QtWidgets.QTextEdit()
        self.results_text.setReadOnly(True)
        self.text_tabs.addTab(self.results_text, "K·∫øt qu·∫£ m√¥ h√¨nh")

        left_layout.addWidget(self.text_tabs)
        results_splitter.addWidget(left_widget)

        # Right panel - Visualizations
        right_widget = QtWidgets.QWidget()
        right_layout = QtWidgets.QVBoxLayout(right_widget)

        # Visualization tabs
        self.viz_tabs = QtWidgets.QTabWidget()

        # Tab 1: Tree visualization
        self.tree_canvas = PlotCanvas()
        self.viz_tabs.addTab(self.tree_canvas, "C√¢y quy·∫øt ƒë·ªãnh")

        # Tab 2: Feature importance
        self.importance_canvas = PlotCanvas()
        self.viz_tabs.addTab(self.importance_canvas, "ƒê·ªô quan tr·ªçng")

        # Tab 3: Target distribution
        self.dist_canvas = PlotCanvas()
        self.viz_tabs.addTab(self.dist_canvas, "Ph√¢n ph·ªëi target")

        # Tab 4: Information Gain Chart - TH√äM M·ªöI
        self.gain_canvas = PlotCanvas()
        self.viz_tabs.addTab(self.gain_canvas, "Information Gain")

        right_layout.addWidget(self.viz_tabs)
        results_splitter.addWidget(right_widget)

        main_layout.addWidget(results_splitter)

        # === PREDICTION SECTION ===
        pred_group = QtWidgets.QGroupBox("4. D·ª± ƒëo√°n")
        pred_group.setMaximumHeight(200)
        pred_main_layout = QtWidgets.QVBoxLayout(pred_group)

        # Input section trong m·ªôt horizontal layout
        input_section = QtWidgets.QWidget()
        input_layout = QtWidgets.QHBoxLayout(input_section)

        # Left side - Input fields
        input_left = QtWidgets.QWidget()
        input_left_layout = QtWidgets.QVBoxLayout(input_left)
        input_left_layout.addWidget(QtWidgets.QLabel("Nh·∫≠p d·ªØ li·ªáu:"))

        self.pred_inputs = {}
        self.pred_scroll = QtWidgets.QScrollArea()
        self.pred_scroll.setMaximumHeight(120)
        self.pred_scroll.setWidgetResizable(True)
        self.pred_widget = QtWidgets.QWidget()
        self.pred_layout = QtWidgets.QFormLayout(self.pred_widget)
        self.pred_scroll.setWidget(self.pred_widget)

        input_left_layout.addWidget(self.pred_scroll)

        pred_btn = QtWidgets.QPushButton("D·ª± ƒëo√°n")
        pred_btn.clicked.connect(self.make_prediction)
        input_left_layout.addWidget(pred_btn)

        input_layout.addWidget(input_left)

        # Right side - Results
        result_right = QtWidgets.QWidget()
        result_layout = QtWidgets.QVBoxLayout(result_right)
        result_layout.addWidget(QtWidgets.QLabel("K·∫øt qu·∫£ d·ª± ƒëo√°n:"))

        self.pred_result = QtWidgets.QTextEdit()
        self.pred_result.setReadOnly(True)
        self.pred_result.setMaximumHeight(120)
        self.pred_result.setText("K·∫øt qu·∫£ d·ª± ƒëo√°n s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y")

        result_layout.addWidget(self.pred_result)
        input_layout.addWidget(result_right)

        pred_main_layout.addWidget(input_section)
        main_layout.addWidget(pred_group)

    def calculate_entropy(self, y):
        """T√≠nh entropy c·ªßa m·ªôt t·∫≠p d·ªØ li·ªáu"""
        if len(y) == 0:
            return 0

        value_counts = pd.Series(y).value_counts()
        probabilities = value_counts / len(y)
        entropy = -sum(p * math.log2(p) for p in probabilities if p > 0)
        return entropy

    def calculate_information_gain(self, X, y, feature):
        """T√≠nh Information Gain cho m·ªôt feature"""
        # Entropy ban ƒë·∫ßu
        initial_entropy = self.calculate_entropy(y)

        # T√≠nh entropy c√≥ tr·ªçng s·ªë sau khi chia theo feature
        feature_values = X[feature].unique()
        weighted_entropy = 0
        split_info = []

        for value in feature_values:
            subset_mask = X[feature] == value
            subset_y = y[subset_mask]
            subset_size = len(subset_y)
            subset_entropy = self.calculate_entropy(subset_y)

            weight = subset_size / len(y)
            weighted_entropy += weight * subset_entropy

            split_info.append({
                'value': value,
                'size': subset_size,
                'entropy': subset_entropy,
                'weight': weight
            })

        information_gain = initial_entropy - weighted_entropy

        return {
            'initial_entropy': initial_entropy,
            'weighted_entropy': weighted_entropy,
            'information_gain': information_gain,
            'split_info': split_info
        }

    def analyze_id3_process(self, X, y):
        """Ph√¢n t√≠ch qu√° tr√¨nh l·ª±a ch·ªçn thu·ªôc t√≠nh theo ID3"""
        self._id3_analysis = []
        self._entropy_analysis = []

        # T√≠nh entropy ban ƒë·∫ßu
        initial_entropy = self.calculate_entropy(y)
        self._entropy_analysis.append({
            'stage': 'Initial Dataset',
            'size': len(y),
            'entropy': initial_entropy,
            'class_distribution': pd.Series(y).value_counts().to_dict()
        })

        # T√≠nh Information Gain cho t·∫•t c·∫£ features
        feature_gains = {}
        feature_details = {}

        for feature in X.columns:
            gain_info = self.calculate_information_gain(X, y, feature)
            feature_gains[feature] = gain_info['information_gain']
            feature_details[feature] = gain_info

        # S·∫Øp x·∫øp theo Information Gain gi·∫£m d·∫ßn
        sorted_features = sorted(feature_gains.items(), key=lambda x: x[1], reverse=True)

        self._id3_analysis.append({
            'stage': 'Root Node Selection',
            'feature_gains': feature_gains,
            'feature_details': feature_details,
            'best_feature': sorted_features[0][0] if sorted_features else None,
            'best_gain': sorted_features[0][1] if sorted_features else 0
        })

        return sorted_features[0][0] if sorted_features else None

    def update_tree_display(self):
        """C·∫≠p nh·∫≠t hi·ªÉn th·ªã c√¢y theo ch·∫ø ƒë·ªô ƒë∆∞·ª£c ch·ªçn"""
        if self._model is not None:
            if self.detailed_tree_check.isChecked():
                self.plot_tree_detailed()
            else:
                self.plot_tree()


    def display_id3_analysis(self):
        """Hi·ªÉn th·ªã k·∫øt qu·∫£ ph√¢n t√≠ch ID3"""
        if not self._id3_analysis:
            return

        analysis_text = "üå≥ PH√ÇN T√çCH QU√Å TR√åNH ID3 DECISION TREE\n"
        analysis_text += "=" * 70 + "\n\n"

        # Hi·ªÉn th·ªã entropy ban ƒë·∫ßu
        if self._entropy_analysis:
            entropy_info = self._entropy_analysis[0]
            analysis_text += f"üìä B∆Ø·ªöC 1: T√çNH ENTROPY BAN ƒê·∫¶U\n"
            analysis_text += f"{'=' * 50}\n"
            analysis_text += f"T·ªïng s·ªë m·∫´u: {entropy_info['size']}\n"
            analysis_text += f"Ph√¢n ph·ªëi l·ªõp:\n"

            for class_label, count in entropy_info['class_distribution'].items():
                probability = count / entropy_info['size']
                analysis_text += f"  ‚Ä¢ {class_label}: {count} m·∫´u ({probability:.3f})\n"

            analysis_text += f"\nüìà Entropy ban ƒë·∫ßu: H(S) = {entropy_info['entropy']:.4f}\n"
            analysis_text += f"C√¥ng th·ª©c: H(S) = -Œ£ p_i * log2(p_i)\n\n"

        # Hi·ªÉn th·ªã ph√¢n t√≠ch t·ª´ng feature
        for analysis in self._id3_analysis:
            if analysis['stage'] == 'Root Node Selection':
                analysis_text += f"üîç B∆Ø·ªöC 2: T√çNH INFORMATION GAIN CHO T·ª™NG THU·ªòC T√çNH\n"
                analysis_text += f"{'=' * 60}\n"

                # S·∫Øp x·∫øp features theo gain gi·∫£m d·∫ßn
                sorted_gains = sorted(analysis['feature_gains'].items(),
                                      key=lambda x: x[1], reverse=True)

                for i, (feature, gain) in enumerate(sorted_gains, 1):
                    details = analysis['feature_details'][feature]
                    analysis_text += f"\n{i}. THU·ªòC T√çNH: {feature.upper()}\n"
                    analysis_text += f"   {'-' * 40}\n"

                    # Chi ti·∫øt chia theo t·ª´ng gi√° tr·ªã
                    analysis_text += f"   Entropy sau khi chia:\n"
                    for split in details['split_info']:
                        analysis_text += f"     ‚Ä¢ {feature} = {split['value']}: "
                        analysis_text += f"{split['size']} m·∫´u, "
                        analysis_text += f"Entropy = {split['entropy']:.4f}, "
                        analysis_text += f"Tr·ªçng s·ªë = {split['weight']:.3f}\n"

                    analysis_text += f"\n   üìä T√≠nh to√°n:\n"
                    analysis_text += f"     ‚Ä¢ Entropy c√≥ tr·ªçng s·ªë: {details['weighted_entropy']:.4f}\n"
                    analysis_text += f"     ‚Ä¢ Information Gain = {details['initial_entropy']:.4f} - {details['weighted_entropy']:.4f}\n"
                    analysis_text += f"     ‚Ä¢ Information Gain = {gain:.4f}\n"

                # K·∫øt lu·∫≠n l·ª±a ch·ªçn
                analysis_text += f"\nüéØ K·∫æT QU·∫¢ L·ª∞A CH·ªåN:\n"
                analysis_text += f"{'=' * 50}\n"
                analysis_text += f"Thu·ªôc t√≠nh ƒë∆∞·ª£c ch·ªçn: {analysis['best_feature']}\n"
                analysis_text += f"Information Gain cao nh·∫•t: {analysis['best_gain']:.4f}\n\n"

                # Ranking table
                analysis_text += f"üìã B·∫¢NG X·∫æP H·∫†NG THU·ªòC T√çNH:\n"
                analysis_text += f"{'=' * 50}\n"
                analysis_text += f"{'H·∫°ng':<5} {'Thu·ªôc t√≠nh':<15} {'Info Gain':<12} {'Ghi ch√∫'}\n"
                analysis_text += f"{'-' * 50}\n"

                for i, (feature, gain) in enumerate(sorted_gains, 1):
                    note = "‚≠ê ƒê∆Ø·ª¢C CH·ªåN" if i == 1 else ""
                    analysis_text += f"{i:<5} {feature:<15} {gain:<12.4f} {note}\n"

                analysis_text += f"\n"

        # Th√™m gi·∫£i th√≠ch thu·∫≠t to√°n
        analysis_text += f"üìö GI·∫¢I TH√çCH THU·∫¨T TO√ÅN ID3:\n"
        analysis_text += f"{'=' * 50}\n"
        analysis_text += f"1. T√≠nh Entropy c·ªßa t·∫≠p d·ªØ li·ªáu g·ªëc\n"
        analysis_text += f"2. V·ªõi m·ªói thu·ªôc t√≠nh:\n"
        analysis_text += f"   - Chia d·ªØ li·ªáu theo gi√° tr·ªã c·ªßa thu·ªôc t√≠nh\n"
        analysis_text += f"   - T√≠nh Entropy c√≥ tr·ªçng s·ªë sau khi chia\n"
        analysis_text += f"   - T√≠nh Information Gain = Entropy_g·ªëc - Entropy_c√≥_tr·ªçng_s·ªë\n"
        analysis_text += f"3. Ch·ªçn thu·ªôc t√≠nh c√≥ Information Gain cao nh·∫•t\n"
        analysis_text += f"4. T·∫°o n√∫t v√† l·∫∑p l·∫°i qu√° tr√¨nh cho t·ª´ng nh√°nh con\n"

        self.id3_analysis_text.setText(analysis_text)

    def plot_information_gain(self):
        """V·∫Ω bi·ªÉu ƒë·ªì Information Gain"""
        if not self._id3_analysis:
            return

        try:
            self.gain_canvas.figure.clear()
            ax = self.gain_canvas.figure.add_subplot(111)

            # L·∫•y d·ªØ li·ªáu gain
            analysis = self._id3_analysis[0]  # Root node analysis
            feature_gains = analysis['feature_gains']

            # S·∫Øp x·∫øp theo gain gi·∫£m d·∫ßn
            sorted_items = sorted(feature_gains.items(), key=lambda x: x[1], reverse=True)
            features = [item[0] for item in sorted_items]
            gains = [item[1] for item in sorted_items]

            # T·∫°o m√†u s·∫Øc (feature ƒë∆∞·ª£c ch·ªçn c√≥ m√†u kh√°c)
            colors = ['red' if i == 0 else 'skyblue' for i in range(len(features))]

            # V·∫Ω bi·ªÉu ƒë·ªì
            bars = ax.bar(range(len(features)), gains, color=colors, alpha=0.7)

            # Th√™m gi√° tr·ªã l√™n ƒë·∫ßu c·ªôt
            for i, (bar, gain) in enumerate(zip(bars, gains)):
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width() / 2., height + 0.01,
                        f'{gain:.4f}', ha='center', va='bottom', fontsize=10)

                # Th√™m d·∫•u sao cho feature ƒë∆∞·ª£c ch·ªçn
                if i == 0:
                    ax.text(bar.get_x() + bar.get_width() / 2., height / 2,
                            '‚≠ê', ha='center', va='center', fontsize=20)

            ax.set_xlabel('Features')
            ax.set_ylabel('Information Gain')
            ax.set_title('Information Gain Analysis (ID3 Algorithm)')
            ax.set_xticks(range(len(features)))
            ax.set_xticklabels(features, rotation=45)
            ax.grid(True, alpha=0.3)

            # Th√™m ch√∫ th√≠ch
            ax.text(0.02, 0.98, 'C·ªôt ƒë·ªè: Thu·ªôc t√≠nh ƒë∆∞·ª£c ch·ªçn\nC·ªôt xanh: Thu·ªôc t√≠nh kh√°c',
                    transform=ax.transAxes, verticalalignment='top',
                    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

            self.gain_canvas.figure.tight_layout()
            self.gain_canvas.draw()

        except Exception as e:
            print(f"L·ªói v·∫Ω bi·ªÉu ƒë·ªì Information Gain: {e}")

    def browse_file(self):
        """Ch·ªçn file d·ªØ li·ªáu"""
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Ch·ªçn file CSV", "", "CSV Files (*.csv);;All Files (*)"
        )
        if not path:
            return

        try:
            # Try different separators
            for sep in [',', ';', '\t']:
                try:
                    df = pd.read_csv(path, sep=sep)
                    if len(df.columns) > 1:
                        self._df_raw = df
                        break
                except:
                    continue

            if self._df_raw is None:
                raise ValueError("Kh√¥ng th·ªÉ ƒë·ªçc file v·ªõi c√°c ƒë·ªãnh d·∫°ng th√¥ng d·ª•ng")

            self.file_line.setText(path)

            # Populate combo boxes
            self.target_combo.clear()
            self.target_combo.addItems(self._df_raw.columns.tolist())

            self.cat_list.clear()
            for col in self._df_raw.columns:
                item = QtWidgets.QListWidgetItem(col)
                self.cat_list.addItem(item)
                if self._df_raw[col].dtype == 'object':
                    item.setSelected(True)

            QtWidgets.QMessageBox.information(
                self, "Th√†nh c√¥ng",
                f"ƒê√£ t·∫£i d·ªØ li·ªáu: {self._df_raw.shape[0]} d√≤ng, {self._df_raw.shape[1]} c·ªôt"
            )

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "L·ªói", f"L·ªói ƒë·ªçc file: {str(e)}")

    def analyze_data(self):
        """Ph√¢n t√≠ch d·ªØ li·ªáu"""
        if self._df_raw is None:
            QtWidgets.QMessageBox.warning(self, "C·∫£nh b√°o", "Ch∆∞a ch·ªçn d·ªØ li·ªáu")
            return

        try:
            # Basic info
            info_text = f"üìä TH√îNG TIN T·ªîNG QUAN\n"
            info_text += f"{'=' * 50}\n"
            info_text += f"üìà K√≠ch th∆∞·ªõc: {self._df_raw.shape[0]} d√≤ng √ó {self._df_raw.shape[1]} c·ªôt\n"
            info_text += f"üìã C√°c c·ªôt: {list(self._df_raw.columns)}\n\n"

            # Missing values
            missing = self._df_raw.isnull().sum()
            info_text += f"‚ùå GI√Å TR·ªä THI·∫æU\n"
            info_text += f"{'=' * 30}\n"
            if missing.sum() == 0:
                info_text += "‚úÖ Kh√¥ng c√≥ gi√° tr·ªã thi·∫øu\n\n"
            else:
                info_text += "‚ö†Ô∏è C√≥ gi√° tr·ªã thi·∫øu:\n"
                for col, count in missing[missing > 0].items():
                    percentage = (count / len(self._df_raw)) * 100
                    info_text += f"  ‚Ä¢ {col}: {count} ({percentage:.1f}%)\n"
                info_text += "\n"

            # Data types
            info_text += f"üî§ KI·ªÇU D·ªÆ LI·ªÜU\n"
            info_text += f"{'=' * 30}\n"
            for col, dtype in self._df_raw.dtypes.items():
                unique_count = self._df_raw[col].nunique()
                info_text += f"  ‚Ä¢ {col}: {dtype} ({unique_count} gi√° tr·ªã duy nh·∫•t)\n"

            # Target analysis if selected
            target_col = self.target_combo.currentText()
            if target_col and target_col in self._df_raw.columns:
                info_text += f"\nüéØ PH√ÇN T√çCH TARGET: {target_col}\n"
                info_text += f"{'=' * 40}\n"
                target_counts = self._df_raw[target_col].value_counts()
                for value, count in target_counts.items():
                    percentage = (count / len(self._df_raw)) * 100
                    info_text += f"  ‚Ä¢ {value}: {count} ({percentage:.1f}%)\n"

            self.data_info_text.setText(info_text)

            # Plot target distribution if target is selected
            if target_col:
                self.plot_target_distribution(target_col)

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "L·ªói", f"L·ªói ph√¢n t√≠ch: {str(e)}")

    def plot_target_distribution(self, target_col):
        """V·∫Ω ph√¢n ph·ªëi target"""
        try:
            self.dist_canvas.figure.clear()
            ax = self.dist_canvas.figure.add_subplot(111)

            value_counts = self._df_raw[target_col].value_counts()
            colors = plt.cm.Set3(np.linspace(0, 1, len(value_counts)))

            bars = ax.bar(range(len(value_counts)), value_counts.values, color=colors)

            # Th√™m gi√° tr·ªã l√™n ƒë·∫ßu c·ªôt
            for bar, count in zip(bars, value_counts.values):
                height = bar.get_height()
                ax.text(bar.get_x() + bar.get_width() / 2., height + 0.5,
                        f'{count}', ha='center', va='bottom')

            ax.set_xlabel(target_col)
            ax.set_ylabel('S·ªë l∆∞·ª£ng')
            ax.set_title(f'Ph√¢n ph·ªëi {target_col}')
            ax.set_xticks(range(len(value_counts)))
            ax.set_xticklabels(value_counts.index, rotation=45)
            ax.grid(True, alpha=0.3)

            self.dist_canvas.figure.tight_layout()
            self.dist_canvas.draw()

        except Exception as e:
            print(f"L·ªói v·∫Ω bi·ªÉu ƒë·ªì: {e}")

    def train_model(self):
        """Hu·∫•n luy·ªán m√¥ h√¨nh v·ªõi ph√¢n t√≠ch ID3"""
        if self._df_raw is None:
            QtWidgets.QMessageBox.warning(self, "C·∫£nh b√°o", "Ch∆∞a ch·ªçn d·ªØ li·ªáu")
            return

        try:
            # Get parameters
            target_col = self.target_combo.currentText()
            if not target_col:
                QtWidgets.QMessageBox.warning(self, "C·∫£nh b√°o", "Ch∆∞a ch·ªçn c·ªôt target")
                return

            self._target_name = target_col

            # Get categorical columns
            cat_cols = [item.text() for item in self.cat_list.selectedItems()]
            if target_col in cat_cols:
                cat_cols.remove(target_col)

            # Prepare data
            df_work = self._df_raw.copy()

            # Encode categorical features
            self._label_encoders = {}
            for col in cat_cols:
                if col in df_work.columns:
                    le = LabelEncoder()
                    df_work[col] = le.fit_transform(df_work[col].astype(str))
                    self._label_encoders[col] = le

            # Prepare features and target
            X = df_work.drop(columns=[target_col])
            y = df_work[target_col]
            self._feature_names = X.columns.tolist()

            # TH·ª∞C HI·ªÜN PH√ÇN T√çCH ID3 TR∆Ø·ªöC KHI TRAIN MODEL
            print("ƒêang ph√¢n t√≠ch qu√° tr√¨nh ID3...")
            self.analyze_id3_process(X, y)
            self.display_id3_analysis()
            self.plot_information_gain()

            # Split data
            test_size = self.test_size_spin.value()
            random_state = self.random_state_spin.value()

            self._X_train, self._X_test, self._y_train, self._y_test = train_test_split(
                X, y, test_size=test_size, random_state=random_state
            )

            # Train model - FORCE entropy for ID3
            criterion = "entropy"  # Always use entropy for ID3
            max_depth = self.depth_spin.value()

            self._model = DecisionTreeClassifier(
                criterion=criterion,
                max_depth=max_depth,
                random_state=random_state
            )

            self._model.fit(self._X_train, self._y_train)

            # Evaluate
            train_pred = self._model.predict(self._X_train)
            test_pred = self._model.predict(self._X_test)

            train_acc = metrics.accuracy_score(self._y_train, train_pred)
            test_acc = metrics.accuracy_score(self._y_test, test_pred)

            # Display results
            results_text = f"üéØ K·∫æT QU·∫¢ HU·∫§N LUY·ªÜN M√î H√åNH\n"
            results_text += f"{'=' * 50}\n"
            results_text += f"üîß Tham s·ªë:\n"
            results_text += f"   ‚Ä¢ Thu·∫≠t to√°n: ID3 (Information Gain + Entropy)\n"
            results_text += f"   ‚Ä¢ Criterion: {criterion}\n"
            results_text += f"   ‚Ä¢ Max depth: {max_depth}\n"
            results_text += f"   ‚Ä¢ Test size: {test_size}\n"
            results_text += f"   ‚Ä¢ Random state: {random_state}\n\n"

            results_text += f"üìä Hi·ªáu su·∫•t:\n"
            results_text += f"   ‚Ä¢ Training accuracy: {train_acc:.4f} ({train_acc * 100:.2f}%)\n"
            results_text += f"   ‚Ä¢ Test accuracy: {test_acc:.4f} ({test_acc * 100:.2f}%)\n"

            # ƒê√°nh gi√° overfitting
            diff = train_acc - test_acc
            if diff > 0.1:
                results_text += f"   ‚ö†Ô∏è  C√≥ d·∫•u hi·ªáu overfitting (ch√™nh l·ªách: {diff:.3f})\n"
            elif diff < 0.05:
                results_text += f"   ‚úÖ M√¥ h√¨nh c√¢n b·∫±ng t·ªët\n"

            results_text += f"\nüìà CLASSIFICATION REPORT\n"
            results_text += f"{'=' * 50}\n"
            results_text += metrics.classification_report(self._y_test, test_pred)

            # Th√™m th√¥ng tin v·ªÅ c·∫•u tr√∫c c√¢y
            results_text += f"\nüå≥ TH√îNG TIN C·∫§U TR√öC C√ÇY\n"
            results_text += f"{'=' * 40}\n"
            results_text += f"   ‚Ä¢ S·ªë l∆∞·ª£ng n√∫t: {self._model.tree_.node_count}\n"
            results_text += f"   ‚Ä¢ S·ªë l∆∞·ª£ng l√°: {self._model.tree_.n_leaves}\n"
            results_text += f"   ‚Ä¢ ƒê·ªô s√¢u th·ª±c t·∫ø: {self._model.tree_.max_depth}\n"

            self.results_text.setText(results_text)

            # Plot visualizations - S·ª¨A PH·∫¶N N√ÄY
            if self.detailed_tree_check.isChecked():
                self.plot_tree_detailed()
            else:
                self.plot_tree()

            self.plot_feature_importance()

            # Setup prediction inputs
            self.setup_prediction_inputs()

            # Chuy·ªÉn sang tab ID3 Analysis
            self.text_tabs.setCurrentIndex(1)

            QtWidgets.QMessageBox.information(
                self, "Th√†nh c√¥ng",
                f"‚úÖ M√¥ h√¨nh ƒë√£ ƒë∆∞·ª£c hu·∫•n luy·ªán!\n"
                f"üìä Test accuracy: {test_acc:.4f} ({test_acc * 100:.2f}%)\n"
                f"üîç Xem tab 'Ph√¢n t√≠ch ID3' ƒë·ªÉ hi·ªÉu qu√° tr√¨nh l·ª±a ch·ªçn thu·ªôc t√≠nh"
            )

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "L·ªói", f"L·ªói hu·∫•n luy·ªán: {str(e)}")
            import traceback
            print(traceback.format_exc())

    def plot_tree(self):
        """V·∫Ω c√¢y quy·∫øt ƒë·ªãnh v·ªõi nh√£n chi ti·∫øt"""
        if self._model is None:
            return

        try:
            self.tree_canvas.figure.clear()
            ax = self.tree_canvas.figure.add_subplot(111)

            # T·∫°o nh√£n t√πy ch·ªânh cho c√°c n√∫t
            feature_names_labeled = []
            for feature in self._feature_names:
                feature_names_labeled.append(f"Feature: {feature}")

            # T·∫°o nh√£n cho c√°c l·ªõp
            class_names_labeled = []
            for class_name in self._model.classes_:
                class_names_labeled.append(f"Class: {str(class_name)}")

            # V·∫Ω c√¢y v·ªõi c√°c tham s·ªë t√πy ch·ªânh
            plot_tree(self._model,
                      feature_names=feature_names_labeled,
                      class_names=class_names_labeled,
                      filled=True,
                      rounded=True,
                      fontsize=9,
                      ax=ax,
                      impurity=True,  # Hi·ªÉn th·ªã entropy/gini
                      proportion=False,  # Hi·ªÉn th·ªã s·ªë m·∫´u th·ª±c t·∫ø thay v√¨ t·ª∑ l·ªá
                      precision=3  # ƒê·ªô ch√≠nh x√°c 3 ch·ªØ s·ªë th·∫≠p ph√¢n
                      )

            # T√πy ch·ªânh ti√™u ƒë·ªÅ v·ªõi th√¥ng tin th√™m
            tree_info = f"Decision Tree (ID3 Algorithm)\n"
            tree_info += f"Criterion: {self._model.criterion} | "
            tree_info += f"Max Depth: {self._model.max_depth} | "
            tree_info += f"Nodes: {self._model.tree_.node_count} | "
            tree_info += f"Leaves: {self._model.tree_.n_leaves}"

            ax.set_title(tree_info, fontsize=12, fontweight='bold', pad=20)

            # Th√™m ch√∫ th√≠ch cho c√°c th√†nh ph·∫ßn c·ªßa n√∫t
            legend_text = """
    Ch√∫ th√≠ch c√°c th√†nh ph·∫ßn trong n√∫t:
    ‚Ä¢ Feature: [T√™n thu·ªôc t√≠nh] <= [Ng∆∞·ª°ng]: ƒêi·ªÅu ki·ªán ph√¢n chia
    ‚Ä¢ entropy/gini: ƒê·ªô ƒëo t·∫°p ch·∫•t (entropy cho ID3)
    ‚Ä¢ samples: S·ªë l∆∞·ª£ng m·∫´u t·∫°i n√∫t n√†y
    ‚Ä¢ value: [S·ªë m·∫´u l·ªõp 0, S·ªë m·∫´u l·ªõp 1, ...]: Ph√¢n ph·ªëi c√°c l·ªõp
    ‚Ä¢ class: L·ªõp d·ª± ƒëo√°n t·∫°i n√∫t n√†y (l·ªõp c√≥ nhi·ªÅu m·∫´u nh·∫•t)

    M√†u s·∫Øc: C√†ng ƒë·∫≠m = ƒê·ªô tinh khi·∫øt c√†ng cao (entropy c√†ng th·∫•p)
    N√∫t l√°: Kh√¥ng c√≥ ƒëi·ªÅu ki·ªán ph√¢n chia, ch·ªâ c√≥ k·∫øt qu·∫£ ph√¢n l·ªõp
            """

            # Th√™m text box ch√∫ th√≠ch ·ªü g√≥c d∆∞·ªõi tr√°i
            ax.text(0.02, 0.02, legend_text.strip(),
                    transform=ax.transAxes,
                    verticalalignment='bottom',
                    horizontalalignment='left',
                    fontsize=8,
                    bbox=dict(boxstyle='round,pad=0.5',
                              facecolor='lightblue',
                              alpha=0.8,
                              edgecolor='navy'))

            self.tree_canvas.figure.tight_layout()
            self.tree_canvas.draw()

        except Exception as e:
            print(f"L·ªói v·∫Ω c√¢y: {e}")

    def plot_tree_detailed(self):
        """V·∫Ω c√¢y quy·∫øt ƒë·ªãnh v·ªõi th√¥ng tin chi ti·∫øt h∆°n (phi√™n b·∫£n m·ªü r·ªông)"""
        if self._model is None:
            return

        try:
            self.tree_canvas.figure.clear()

            # T·∫°o subplot v·ªõi t·ª∑ l·ªá ph√π h·ª£p
            fig = self.tree_canvas.figure
            gs = fig.add_gridspec(3, 1, height_ratios=[0.1, 2.5, 0.4], hspace=0.3)

            # Subplot cho ti√™u ƒë·ªÅ
            ax_title = fig.add_subplot(gs[0])
            ax_title.axis('off')

            # Subplot ch√≠nh cho c√¢y
            ax_main = fig.add_subplot(gs[1])

            # Subplot cho ch√∫ th√≠ch
            ax_legend = fig.add_subplot(gs[2])
            ax_legend.axis('off')

            # V·∫Ω c√¢y quy·∫øt ƒë·ªãnh
            plot_tree(self._model,
                      feature_names=[f"üìä {feature}" for feature in self._feature_names],
                      class_names=[f"üéØ {str(c)}" for c in self._model.classes_],
                      filled=True,
                      rounded=True,
                      fontsize=8,
                      ax=ax_main,
                      impurity=True,
                      proportion=False,
                      precision=3)

            # Ti√™u ƒë·ªÅ chi ti·∫øt
            title_text = f"üå≥ DECISION TREE - ID3 ALGORITHM\n"
            title_text += f"Criterion: {self._model.criterion.upper()} | "
            title_text += f"Max Depth: {self._model.max_depth} | "
            title_text += f"Total Nodes: {self._model.tree_.node_count} | "
            title_text += f"Leaf Nodes: {self._model.tree_.n_leaves}"

            ax_title.text(0.5, 0.5, title_text,
                          ha='center', va='center',
                          fontsize=12, fontweight='bold',
                          transform=ax_title.transAxes)

            # Ch√∫ th√≠ch chi ti·∫øt
            legend_content = """
            """

            ax_legend.text(0.02, 0.98, legend_content.strip(),
                           transform=ax_legend.transAxes,
                           verticalalignment='top',
                           horizontalalignment='left',
                           fontsize=9,
                           bbox=dict(boxstyle='round,pad=0.8',
                                     facecolor='lightyellow',
                                     alpha=0.9,
                                     edgecolor='orange',
                                     linewidth=2))

            self.tree_canvas.draw()

        except Exception as e:
            print(f"L·ªói v·∫Ω c√¢y chi ti·∫øt: {e}")
            # Fallback v·ªÅ ph∆∞∆°ng th·ª©c c≈©
            self.plot_tree()

    def plot_feature_importance(self):
        """V·∫Ω ƒë·ªô quan tr·ªçng c·ªßa features"""
        if self._model is None:
            return

        try:
            self.importance_canvas.figure.clear()
            ax = self.importance_canvas.figure.add_subplot(111)

            importance = self._model.feature_importances_
            indices = np.argsort(importance)[::-1]

            colors = plt.cm.viridis(np.linspace(0, 1, len(importance)))
            bars = ax.bar(range(len(importance)), importance[indices], color=colors)

            # Th√™m gi√° tr·ªã l√™n ƒë·∫ßu c·ªôt
            for bar, imp in zip(bars, importance[indices]):
                height = bar.get_height()
                if height > 0:
                    ax.text(bar.get_x() + bar.get_width() / 2., height + 0.01,
                            f'{height:.3f}', ha='center', va='bottom', fontsize=10)

            ax.set_xlabel('Features')
            ax.set_ylabel('Importance')
            ax.set_title('Feature Importance (t·ª´ m√¥ h√¨nh ƒë√£ hu·∫•n luy·ªán)')
            ax.set_xticks(range(len(importance)))
            ax.set_xticklabels([self._feature_names[i] for i in indices], rotation=45)
            ax.grid(True, alpha=0.3)

            self.importance_canvas.figure.tight_layout()
            self.importance_canvas.draw()

        except Exception as e:
            print(f"L·ªói v·∫Ω feature importance: {e}")

    def setup_prediction_inputs(self):
        """Thi·∫øt l·∫≠p c√°c tr∆∞·ªùng input cho d·ª± ƒëo√°n"""
        # Clear existing inputs
        for i in reversed(range(self.pred_layout.count())):
            child = self.pred_layout.itemAt(i).widget()
            if child:
                child.deleteLater()

        self.pred_inputs = {}

        for feature in self._feature_names:
            if feature in self._label_encoders:
                # Categorical feature - use combo box
                combo = QtWidgets.QComboBox()
                combo.addItems(self._label_encoders[feature].classes_)
                self.pred_inputs[feature] = combo
                self.pred_layout.addRow(f"{feature}:", combo)
            else:
                # Numerical feature - use line edit
                line_edit = QtWidgets.QLineEdit()
                line_edit.setPlaceholderText("Nh·∫≠p gi√° tr·ªã s·ªë")
                self.pred_inputs[feature] = line_edit
                self.pred_layout.addRow(f"{feature}:", line_edit)

    def make_prediction(self):
        """Th·ª±c hi·ªán d·ª± ƒëo√°n"""
        if self._model is None:
            QtWidgets.QMessageBox.warning(self, "C·∫£nh b√°o", "Ch∆∞a hu·∫•n luy·ªán m√¥ h√¨nh")
            return

        try:
            # Collect input values
            input_data = {}
            for feature, widget in self.pred_inputs.items():
                if isinstance(widget, QtWidgets.QComboBox):
                    # Categorical feature
                    value = widget.currentText()
                    encoded_value = self._label_encoders[feature].transform([value])[0]
                    input_data[feature] = encoded_value
                else:
                    # Numerical feature
                    try:
                        text_value = widget.text().strip()
                        if not text_value:
                            QtWidgets.QMessageBox.warning(
                                self, "L·ªói", f"Vui l√≤ng nh·∫≠p gi√° tr·ªã cho {feature}"
                            )
                            return
                        value = float(text_value)
                        input_data[feature] = value
                    except ValueError:
                        QtWidgets.QMessageBox.warning(
                            self, "L·ªói", f"Gi√° tr·ªã kh√¥ng h·ª£p l·ªá cho {feature}"
                        )
                        return

            # Make prediction
            input_df = pd.DataFrame([input_data])
            prediction = self._model.predict(input_df)[0]
            probabilities = self._model.predict_proba(input_df)[0]

            # Format k·∫øt qu·∫£ hi·ªÉn th·ªã
            result_text = f"üéØ K·∫æT QU·∫¢ D·ª∞ ƒêO√ÅN\n"
            result_text += f"{'=' * 30}\n\n"
            result_text += f"üèÜ D·ª± ƒëo√°n: {prediction}\n\n"
            result_text += f"üìä X√°c su·∫•t cho t·ª´ng l·ªõp:\n"

            # S·∫Øp x·∫øp theo x√°c su·∫•t gi·∫£m d·∫ßn
            prob_pairs = list(zip(self._model.classes_, probabilities))
            prob_pairs.sort(key=lambda x: x[1], reverse=True)

            for class_name, prob in prob_pairs:
                emoji = "ü•á" if prob == max(probabilities) else "üìà"
                result_text += f"   {emoji} {class_name}: {prob:.4f} ({prob * 100:.2f}%)\n"

            # Th√™m th√¥ng tin input ƒë√£ nh·∫≠p
            result_text += f"\nüìù D·ªÆ LI·ªÜU ƒê·∫¶U V√ÄO:\n"
            result_text += f"{'=' * 25}\n"
            for feature, widget in self.pred_inputs.items():
                if isinstance(widget, QtWidgets.QComboBox):
                    value = widget.currentText()
                else:
                    value = widget.text()
                result_text += f"   ‚Ä¢ {feature}: {value}\n"

            self.pred_result.setText(result_text)

        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "L·ªói", f"L·ªói d·ª± ƒëo√°n: {str(e)}")
            self.pred_result.setText("‚ùå C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh d·ª± ƒëo√°n")


class PlotCanvas(FigureCanvas):
    """Canvas ƒë·ªÉ hi·ªÉn th·ªã matplotlib plots"""

    def __init__(self, parent=None, width=8, height=6, dpi=100):
        self.figure = Figure(figsize=(width, height), dpi=dpi)
        super().__init__(self.figure)
        self.setParent(parent)


# =============================== MAIN ===============================
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    gui = ID3AnalyzerGUI()
    gui.show()
    sys.exit(app.exec_())